---
layout: reveal_markdown
title: "K-mer analysis and membership testers"
tags: slides 
date: 2021-12-09
---


## {{ page.title }}
---
## Lecture overview

- What are k-mers and why are they useful?
- RNA pseudoalignment
- Membership testers
  - Bloom filters
  - Hash functions

---
### What are k-mers?

> subsequences of length *k*.

---
<div class="row">
<div class="col">
<h2>3-mers</h2>
<div class="mermaid">
graph TD;
  TCGA-->TCG;
  TCGA-->CGA;
</div>
</div>
<div class="col">
<h2>2-mers</h2>
<div class="mermaid">
graph TD;
  TCGA-->TC;
  TCGA-->CG;
  TCGA-->GA;
</div>
</div>
</div>
---
How many 7-mers are there  
in a sequence with $l=11$ bases?

<div class="fragment">
$x = l-k+1 = 5$

```
|ABCDEFGHIJK|
|1-----7    | 1
| 1-----7   | 2
|  1-----7  | 3
|   1-----7 | 4
|    1-----7| 5
```
</div>
---
Human chromosome 1 has 248,956,422 bp.  

> Assuming a random distribution of 4 bases, what is the expected count of a given 7-mer on human chromosome 1?

---

$l = 248,956,422$ size of chr1  
$l-k+1 = 248,956,416$ total 7-mers in chr1  

$4^7 = 16384$ possible 7-mer types  
$ 248,956,416 / 16384 \approx \mathbf{15195} $ 

---
## Kmers and motifs
<div class="row">
<div class="col">
<h2>K-mer</h2>
<div class="mermaid">
graph TD;
  TCGA-->TCG;
  TCGA-->CGA;
</div>
</div>
<div class="col">
<h2>Motif</h2>

<img src="images/k-mer-analysis/motif.png" height="200">
</div>
</div>


- A k-mer is like a simplified motif with no weights
- K-mers are faster to compute and require less data
- K-mers represent a single instance, rather than a set
---
## Applications of K-mers
- Alignment seeds (fast RNA counting)
- Counting for relationships (e.g. metagenomics)
- Dinucleotide/codon analysis, background models
- Sequence assembly (De Bruijn graphs)
- Simplified transcription factor binding



---
## RNA Psuedoalignment

---
## RNA Psuedoalignment

---
## RNA Psuedoalignment

---
## K-mer Counting

<div class="mermaid">
graph TD
  GATTACAGATTCAG-->GAT;
  GATTACAGATTCAG-->ATT;
  GATTACAGATTCAG-->TTA;
  GATTACAGATTCAG-->TAC;
  GATTACAGATTCAG-->ACA;
  GATTACAGATTCAG-->ATT;
  GATTACAGATTCAG-->CAG;
  GATTACAGATTCAG-->AGA;
  GATTACAGATTCAG-->TTC;
  GATTACAGATTCAG-->TCA;
  GATTACAGATTCAG-->CAG;
  GAT-->n([1]);
  ATT-->n2([2]);
  TTA-->n3([1]);
  TAC-->n4([1]);
  ACA-->n5([1]);
  CAG-->n6([2]);
  AGA-->n7([1]);
  TTC-->n8([1]);
  TCA-->n9([1]);
</div>

K-mer counting converts a sequence into a vector

<div class="mermaid fragment">
graph LR
  GATTACAGATTCAG-->n1["1 2 1 1 1 1 2 1 1 1"];
  CTGAGGACTCGACT-->n2["2 1 0 0 2 2 3 2 2 1"];;
</div>


---
### Exponential growth

$4^k$

```
> cbind(k=seq(1,20), combinations=4^seq(1, 20))
       k  combinations
 [1,]  1             4
 [2,]  2            16
 [3,]  3            64
 [4,]  4           256
 [5,]  5          1024
 [6,]  6          4096
 [7,]  7         16384
 [8,]  8         65536
 [9,]  9        262144
[10,] 10       1048576
[11,] 11       4194304
[12,] 12      16777216
[13,] 13      67108864
[14,] 14     268435456
[15,] 15    1073741824
[16,] 16    4294967296
[17,] 17   17179869184
[18,] 18   68719476736
[19,] 19  274877906944
[20,] 20 1099511627776
```

High $k$ $\rightarrow$ high-dimensional vectors, sparsity

---
### Hashing

> A hash function maps an object to a finite space

- must be deterministic
- should be very fast to compute
- should reduce collisions
---
![](images/k-mer-analysis/hash_function.png)

---

### Hash tables
- provide $O(1)$ complexity for item access
- Can store large objects for lookup with a key

---
### Cryptographic hash function
- a subset of hash functions with particular purposes:
  - designed to go one way (hard to de-hash)
  - designed to avoid collisions
  - relies on the avalanche effect (small change in inputs leads to large change in output)


---
### md5 algorithm- "Message Digest"

In 2011, the Internet Engineering Task Force (IETF) [advised in this document](https://tools.ietf.org/search/rfc6151) that

> The published attacks against MD5 show that it is not prudent to use MD5 when collision resistance is required.


---

## Bloom filters

- Probabilistic membership testers using hash tables
- Guarantee an item *is not* in the set, but not if it is (false positives allowed)
- Elements cannot be removed from the set
- Are very fast and memory efficient
---
![](images/k-mer-analysis/bloom_filters.svg)
---
## Properties of bloom filters

- Size: how many elements in the bit vector?
- Number of hash functions
- Hash functions themselves
---
## Classic hash functions 

...

---
## hash function tweaks

- deliberate nonuniformity
- tradeoff of number of functions and speed, and fill rate
- Kirsch-Mitzenmacher optimization
- counting filters
- cuckoo filters

--
## MinHash

